<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GG Blog</title>
    <description>GG is on the way to being a master! Every failure is leading towards success.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 25 Feb 2018 15:41:02 +0800</pubDate>
    <lastBuildDate>Sun, 25 Feb 2018 15:41:02 +0800</lastBuildDate>
    <generator>Jekyll v3.7.2</generator>
    
      <item>
        <title>高级算法</title>
        <description>&lt;h1 id=&quot;高级算法&quot;&gt;高级算法&lt;/h1&gt;
&lt;p&gt;1.包含四种算法：==数值概率算法==（数值问题的求解，最优化问题的近似解）、==蒙特罗卡Monte Carlo算法==（判定问题的准确解，不一定正确）、==拉斯维加斯Las Vegas算法==（不一定会得到解，但得到的解一定是正确解）、==舍伍德Sherwood算法==（总能求得一个解，且一定是正确解，主要作用是减少或是消除好的和坏的实例之间的差别）&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95/</guid>
        
        
      </item>
    
      <item>
        <title>队列</title>
        <description>&lt;h1 id=&quot;队列&quot;&gt;队列&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;假设==循环队列==的队尾指针是rear，队头是front，其中QueueSize为循环队列的最大长度。&lt;br /&gt;
(1) 入队时队尾指针前进1：(rear+1)%QueueSize&lt;br /&gt;
(2) 出队时队头指针前进1：(front+1)%QueueSize&lt;br /&gt;
(3) 队列长度：(rear-front+QueueSize)%QueueSize&lt;br /&gt;
(4) 队满条件为：(rear+1)%QueueSize==front&lt;br /&gt;
(5) 队空条件为：front == rear&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;普通队列: 满队列的条件QU-&amp;gt;rear － QU-&amp;gt;front = = m0&lt;/li&gt;
  &lt;li&gt;在链队列中,即使不设置尾指针也能进行入队操作:遍历整个队列，当一个元素的next为null时，则此元素为最后一个，在其后面添加新的元素。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E9%98%9F%E5%88%97/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E9%98%9F%E5%88%97/</guid>
        
        
      </item>
    
      <item>
        <title>链表</title>
        <description>&lt;h1 id=&quot;链表&quot;&gt;链表&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求==待查表为有序表、顺序存储结构==，且插入删除困难。&lt;/li&gt;
  &lt;li&gt;线性表中利用==带头结点的双循环链表==存储方式最省时间。&lt;/li&gt;
  &lt;li&gt;线性表的顺序存储结构是一种==随机存取、顺序存储==的存储结构。顺序存储指内存地址是一块的，随机存取指访问时可以按下标随机访问。&lt;/li&gt;
  &lt;li&gt;线性表有两种存储结构：
1.==顺序存储结构—顺序表==。顺序表以数组形式出现，可以取任意下标访问，所以是一种随机存取的存储结构。
2.==链式存储结构—链表==。链表以链表的形式出现，必须从头开始访问，所以是一种顺序存取的存储结构。&lt;/li&gt;
  &lt;li&gt;链表head为空的判定条件：==带头结点单链表==：head-&amp;gt;next == NULL；==带头结点循环链表==：head-&amp;gt;next == head；==不带头结点单链表==：head==NULL。&lt;/li&gt;
  &lt;li&gt;顺序存储结构在物理上一般是连续存储，而链式存储一般不占用连续空间，相对而言，顺序存储的存储密度就大，链式存储不但要存储节点的值，还有对应的指针信息。 同样的内存空间，顺序存储不需要额外的信息。&lt;/li&gt;
  &lt;li&gt;链表方便删除和插入，只需知道结点和要插入的信息即可；长度可变，一般链表是动态分配内存空间；链表的结点信息至少包含数据域和指针域，相同数据下：数组的大小是链表大小的子集。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;广义表：表==头可以为表或单元素值==，表==尾是指除去表头后剩下的元素组成的表==（即使只剩一个元素也视为表），可以为空表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;==线性结构==指的是数据元素之间存在着“一对一”的线性关系的数据结构。
常用的线性结构有：==线性表，栈，队列，双队列，数组，串。==
==非线性结构==的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继。
如==树，表，多维数组==等。&lt;/li&gt;
  &lt;li&gt;区别==长度无穷大和无限列表==，由于计算机资源的限制，长度无穷大的广义表==不能==在计算机中实现。 但是如果考虑这样一个广义表 E = (a, E) ——这是一个==递归的表==，它的长度是 2 。E相当于一个无限的列表 E = (a, (a, (a, …)))，这个广义表是==可以在计算机中实现==的。&lt;/li&gt;
  &lt;li&gt;ArrayList由数组实现，LinkedList由链表实现，数组的访问速度比链表快，==HashMap允许将null用作键或值。==&lt;/li&gt;
  &lt;li&gt;==链接存储结构==是在计算机中用一组任意的存储单元存储线性表的数据元素。
链式存储结构特点：&lt;br /&gt;
1、比顺序存储结构的==存储密度小== (每个节点都由数据域和指针域组成，所以相同空间内假设全存满的话顺序比链式存储更多)。
2、逻辑上相邻的节点物理上不必相邻。
3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。
4、查找结点时链式存储要比顺序存储慢。
5、每个结点是由数据域和指针域组成。&lt;/li&gt;
  &lt;li&gt;广义表中：==长度==：去掉一层括号剩下的是几部分。 
==深度==：去掉几层括号可以到最后一部分。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E9%93%BE%E8%A1%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E9%93%BE%E8%A1%A8/</guid>
        
        
      </item>
    
      <item>
        <title>递归</title>
        <description>&lt;h1 id=&quot;递归&quot;&gt;递归&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;递归的过程，利用==栈==保存现场地址，然后将数据入栈，运算，后出栈，返回结果。递归工作栈里面包括==返回地址、本层的局部变量和递归调用的形参代换用实参==，所以正常情况下，无论递归过程有没有使用局部变量，转换为非递归过++程都需要用栈++来模拟这个递归调用过程&lt;/li&gt;
  &lt;li&gt;==fork()给子进程返回一个零值，而给父进程返回一个非零值；==
在main这个主进程中，首先执行 fork() || fork(), 左边的fork()返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，
由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中， fork() ||fork()这条语句左边表达式的返回值是0, 所以||右边的表达式要执行，这时在子进程中又创建了一个进程，
即main进程-&amp;gt;子进程-&amp;gt;子进程，一共创建了3个进程。&lt;/li&gt;
  &lt;li&gt;n！后面有多少个0（现在算10000的阶乘末尾有几个零）：10000/==5== + 10000/==25== + 10000/==125== + 10000/==625== + 10000/==3125== = 2499。&lt;/li&gt;
  &lt;li&gt;在快速排序中，需要使用递归来分别处理左右子段，==递归深度可以理解为系统栈保存的深度,先处理短的分段再处理长的分段，可以减少时间复杂度==；
如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。&lt;/li&gt;
  &lt;li&gt;使用多线程的方式提高 I/O 密集型操作的效率==不可以用来程序调优.可以通过异步读写、合并读写、计算代替读写等方式优化==。利用数据库连接池替代直接的数据库访问可以==减少连接和断开数据库的开销==。利用迭代替代递归可以==减少运行时对程序栈进行操作的开销==。&lt;/li&gt;
  &lt;li&gt;递归函数中的形参是==自动变量==。递归是借助==栈==来实现的，自动变量是存储在栈里面的，随着递归的进行，自动创建和销毁。
外部变量和静态变量存放在==静态存储区==。外部变量和静态变量是不能作为递归函数的参数的。&lt;/li&gt;
  &lt;li&gt;任何一个递归过程都可以转换成非递归过程，但++转换为循环处理++只有==尾递归==才行。&lt;/li&gt;
  &lt;li&gt;注意区分==递归深度和递归次数==，无论是先长还是先短，递归次数是不变的，但递归深度依据给定数据会==在O(logN)~O(N)之==间变化。
原因是对两部分待排序区间进行递归形成的是二叉树，递归深度取决于二叉树的高度。
如果轴点恰好平分两个待排序部分，那么递归深度达到最优，即O(logN)，但如果轴点使两部分极不平衡，那么二叉树就会退化为单链表，其深度会达到O(N)。&lt;/li&gt;
  &lt;li&gt;算法的5个基本特征：==确定性、有穷性、输入、输出、可行性==。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E9%80%92%E5%BD%92/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E9%80%92%E5%BD%92/</guid>
        
        
      </item>
    
      <item>
        <title>软件工程</title>
        <description>&lt;h1 id=&quot;软件工程&quot;&gt;软件工程&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;从==总体到具体==的关联关系排列应该是软件工程、软件过程、软件产品、软件项目。&lt;/li&gt;
  &lt;li&gt;六种覆盖方法中==覆盖准则由弱到强==依次是++语句覆盖、判定覆盖（分支覆盖）、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖++。
其中，
语句覆盖是使得程序中每个语句至少被执行一次；
判定覆盖是使得程序中的每个分支至少都通过一次；
条件覆盖是使得判定中的每个条件获得各种可能的结果；
判定/条件覆盖是使得判定中的每个条件取到各种可能的值，并使每个判定取到各种可能的结果；
条件组合覆盖是使得每个判定中条件的各种可能组合都至少出现一次。&lt;/li&gt;
  &lt;li&gt;==黑盒==测试用例设计方法包括等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景法等。==白盒==测试的测试方法有代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径测试法、域测试、符号测试、路径覆盖和程序变异。&lt;/li&gt;
  &lt;li&gt;边界值分析法：是使用在++最小值、略高于最小值、正常值、略低于最大值和最大值++处取输入变量值。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</guid>
        
        
      </item>
    
      <item>
        <title>网络基础</title>
        <description>&lt;h1 id=&quot;网络基础&quot;&gt;网络基础&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;ICMP的差错报告都是==网关—源机==模式的：一旦发生错误，差错情况报告信源机.
差错报文包括 ：目标不可到达（网络、协议、主机、端口不可到达；禁止分割、目标网络不认识、目标主机不认识等等）、超时、参数问题、重定向（网络重定向、主机重定向等）&lt;/li&gt;
  &lt;li&gt;IP报头中的==生存期（TTL）属性==，用来控制报文段在网络中的生存期。 当TTL值为0时，路由器判断数据包超时，发送ICMP超时信息给源主机.&lt;/li&gt;
  &lt;li&gt;100Base-T 使用==光纤==传输介质。&lt;/li&gt;
  &lt;li&gt;路由器网络设备用来==隔绝广播。==&lt;/li&gt;
  &lt;li&gt;在服务器的网络编程中，解决会话跟踪的方法有：1，使用cookie
2，隐藏表单域
3，URL重写
4，session&lt;/li&gt;
  &lt;li&gt;ZigBee技术是一种短距离、低功耗的无线通信技术。
ZigBee协议从下到上分别为物理层(PHY)、媒体访问控制层(MAC)、传输层(TL)、网络层(NWK)、应用层(APL)等。&lt;/li&gt;
  &lt;li&gt;十进制数加调整指令DAA(Decimal Adjust After Addition)该指令是用于调整AL的值,该值是由指令ADD或ADC运算二个压缩型BCD码所得到的结果.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
        
        
      </item>
    
      <item>
        <title>编译和体系结构</title>
        <description>&lt;h1 id=&quot;编译和体系结构&quot;&gt;编译和体系结构&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;十进制数加调整指令==DAA==(Decimal Adjust After Addition)该指令是用于调整AL的值,该值是由指令ADD或ADC运算二个压缩型BCD码所得到的结果.&lt;/li&gt;
  &lt;li&gt;==指令指针寄存器==是IP，PSW即==程序状态字==。&lt;/li&gt;
  &lt;li&gt;==微波==标签工作频率是 2.45GHz 。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E7%BC%96%E8%AF%91%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid>
        
        
      </item>
    
      <item>
        <title>编程基础</title>
        <description>&lt;h1 id=&quot;编程基础&quot;&gt;编程基础&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;在程序中存放指令地址的寄存器叫==程序计数器==。&lt;/li&gt;
  &lt;li&gt;永久删除-》==Shift+Del==。&lt;/li&gt;
  &lt;li&gt;虚拟内存指的是==用硬盘中的一部分存储空间当作内存==。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
        
        
      </item>
    
      <item>
        <title>树</title>
        <description>&lt;h1 id=&quot;树&quot;&gt;树&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;m阶B-树的所有叶子都在==同一==层次上。&lt;/li&gt;
  &lt;li&gt;最优二叉树：哈夫曼树。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kruskal算法是==按权值选边==，若选边后不形成回路,则保留作为一条边,若形成回路则除去。
Prim算法是每次==从当前的二叉树节点向外延伸==的，选择权值最小的边。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;分支节点是度不为0的节点。设树高h,因为是满二叉树，所以叶子节点有2^(h-1)个。&lt;br /&gt;
有n(n&amp;gt;0)个分支结点的满二叉树的深度：==h=log2(n+1)+1==。&lt;/li&gt;
  &lt;li&gt;二叉链表作为树的存储结构时，链表中结点的两个链域分别指向==该结点的第一个孩子结点==和==第一个孩子下一个兄弟结点==。&lt;/li&gt;
  &lt;li&gt;不同的求最小生成树的方法最后得到的生成树不唯一，但最小生成树上权值之和相等。&lt;/li&gt;
  &lt;li&gt;设度为0的结点数为n0，度为1的结点数为n1，度为2的结点数为n2，二叉树的总结点为n，&lt;br /&gt;
则 ==n0 + n1 + n2 = n==（1）&lt;br /&gt;
对任意数，分支数b=n-1，对二叉树来说，所有的分支是由度为1和2的结点出发的，故b=n1+2*n2&lt;br /&gt;
则 ==2 × n2 + 1 × n1+1 = n==（2）&lt;br /&gt;
==n0 = n2 + 1==&lt;/li&gt;
  &lt;li&gt;K层总共最多是：2^k -1   满二叉树. 第K层最多是：2^(k-1)  第k层是满的。&lt;/li&gt;
  &lt;li&gt;完全二叉树叶子节点：==n0＝（n＋1）/2==。&lt;br /&gt;
 完全二叉树的深度公式：==↓log(2 N)↓+1==，注意是以2为底向下取整的整数再加1。&lt;/li&gt;
  &lt;li&gt;采用二叉链表作为存储结构,==树的前序遍历和其相应的二叉树的前序遍历==的结果是一样，==树的后序遍历和其相应的二叉树的中序遍历==一致。&lt;/li&gt;
  &lt;li&gt;B树 是一种==多路搜索树==（并不是二叉的）：
    &lt;ol&gt;
      &lt;li&gt;定义任意非叶子结点最多只有   M   个儿子；且   M&amp;gt;2   ；&lt;/li&gt;
      &lt;li&gt;根结点的儿子数为   [2, M]   ；&lt;/li&gt;
      &lt;li&gt;除根结点以外的非叶子结点的儿子数为   [M/2, M]   ；&lt;/li&gt;
      &lt;li&gt;每个结点存放至少   M/2-1   （取上整）和至多   M-1   个关键字；（至少   2   个关键字）&lt;/li&gt;
      &lt;li&gt;非叶子结点的关键字个数   =   指向儿子的指针个数   -1   ；&lt;/li&gt;
      &lt;li&gt;非叶子结点的关键字：   K[1], K[2], …, K[M-1]   ；且   K[i] &amp;lt; K[i+1]   ；&lt;/li&gt;
      &lt;li&gt;非叶子结点的指针：   P[1], P[2], …, P[M]   ；其中   P[1]   指向关键字小于   K[1]   的子树，   P[M]   指向关键字大于   K[M-1]   的子树，其它   P[i]   指向关键字属于   (K[i-1], K[i])   的子树；&lt;/li&gt;
      &lt;li&gt;所有叶子结点位于同一层；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E6%A0%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E6%A0%91/</guid>
        
        
      </item>
    
      <item>
        <title>栈</title>
        <description>&lt;h1 id=&quot;栈&quot;&gt;栈&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;出栈不同排列顺序：卡特兰数公式 h(n)=C(2n[下]，n[上])/(n+1)，适用于出栈情况求和
==C(2n,n)-C(2n,n+1)==&lt;/li&gt;
  &lt;li&gt;通常元素==进栈==的操作是先移动栈顶指针，再存入元素；元素==出栈==的操作是先取出元素，再移动栈顶指针。栈的顺序存储空间为S(1:50)，初始状态top=51，所以这个栈是50在栈底，1是==开口向上==的。&lt;/li&gt;
  &lt;li&gt;存储结构是数据的逻辑结构用计算机语言的实现，常见的存储结构有： ==顺序存储 ， 链式存储 ， 索引存储 ，以及 散列存储== 。其中散列所形成的存储结构叫 散列表（又叫哈希表） ，因此哈希表也是一种存储结构。栈只是一种抽象数据类型，是一种逻辑结构，栈逻辑结构对应的顺序存储结构为顺序栈，对应的链式存储结构为链栈，循环队列是顺序存储结构，链表是线性表的链式存储结构。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据结构:&lt;br /&gt;
(1). 逻辑结构：==线性、树形、图形==结构  &lt;br /&gt;
(2). 存储结构： （a）顺序存储结构，如数组 （b）链式存储结构，如链表 （c）索引存储，如线索树 （d）散列存储 栈，可以用顺序存储实现，（其实就是数组加一个top指针），也可以用链式存储结构实现，如链栈。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;==局部变量、函数内动态申请的对象、函数内指向动态申请的对象的局部指针变量==是分配在栈上的，==new出来的对象==是分配在堆上。&lt;/li&gt;
  &lt;li&gt;在栈中，栈底保持不变，有元素入栈，栈顶指针增加；有元素出栈，栈顶指针减小。在循环队列中，队头指针和队尾指针的动态变化决定队列的长度。在循环链表中，前一个结点指向后一个结点，而最后一个结点指向头结点，==只有头结点是固定的==。线性链表中，由于前一个结点包含下一个结点的指针，尾结点指针为空，要插入删除元素，只需要改变相应位置的结点指针即可，头指针和尾指针无法决定链表长度。&lt;/li&gt;
  &lt;li&gt;线索二叉树的节点增加了指向前驱结点和指向后继节点的标志，因此在==遍历时无需用栈.==&lt;/li&gt;
  &lt;li&gt;栈的==常见应用==：浏览器历史纪录，Android中的最近任务，Activity的启动模式，CPU中栈的实现，Word自动保存，解析计算式，解析xml/json。&lt;/li&gt;
  &lt;li&gt;栈的表示在不同的书上一般有两种表达方式：&lt;br /&gt;
1.top指针指向栈顶元素，这样下一个出栈的元素就是top指向的结点元素；此时入栈操作为==p-&amp;gt;next=Top; Top=p==;&lt;br /&gt;
2.top指向下一个可以入栈的位置，这样就相当于top是带头结点的链表中的头节点，然后入栈的话就要插入到top的下一个节点位置；此时入栈操作为==p-&amp;gt;next=Top-&amp;gt;next;Top-&amp;gt;next=p;==&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 25 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/02/25/%E6%A0%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/02/25/%E6%A0%88/</guid>
        
        
      </item>
    
  </channel>
</rss>
