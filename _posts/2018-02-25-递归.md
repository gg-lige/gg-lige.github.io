# 递归
1. 递归的过程，利用==栈==保存现场地址，然后将数据入栈，运算，后出栈，返回结果。递归工作栈里面包括==返回地址、本层的局部变量和递归调用的形参代换用实参==，所以正常情况下，无论递归过程有没有使用局部变量，转换为非递归过++程都需要用栈++来模拟这个递归调用过程
2. ==fork()给子进程返回一个零值，而给父进程返回一个非零值；==
在main这个主进程中，首先执行 fork() || fork(), 左边的fork()返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程，
由于子进程会复制父进程，而且子进程会根据其返回值继续执行，就是说，在子进程中， fork() ||fork()这条语句左边表达式的返回值是0, 所以||右边的表达式要执行，这时在子进程中又创建了一个进程，
即main进程->子进程->子进程，一共创建了3个进程。
3. n！后面有多少个0（现在算10000的阶乘末尾有几个零）：10000/==5== + 10000/==25== + 10000/==125== + 10000/==625== + 10000/==3125== = 2499。
4. 在快速排序中，需要使用递归来分别处理左右子段，==递归深度可以理解为系统栈保存的深度,先处理短的分段再处理长的分段，可以减少时间复杂度==；
如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。
5. 使用多线程的方式提高 I/O 密集型操作的效率==不可以用来程序调优.可以通过异步读写、合并读写、计算代替读写等方式优化==。利用数据库连接池替代直接的数据库访问可以==减少连接和断开数据库的开销==。利用迭代替代递归可以==减少运行时对程序栈进行操作的开销==。
6. 递归函数中的形参是==自动变量==。递归是借助==栈==来实现的，自动变量是存储在栈里面的，随着递归的进行，自动创建和销毁。
外部变量和静态变量存放在==静态存储区==。外部变量和静态变量是不能作为递归函数的参数的。
7. 任何一个递归过程都可以转换成非递归过程，但++转换为循环处理++只有==尾递归==才行。
8. 注意区分==递归深度和递归次数==，无论是先长还是先短，递归次数是不变的，但递归深度依据给定数据会==在O(logN)~O(N)之==间变化。
原因是对两部分待排序区间进行递归形成的是二叉树，递归深度取决于二叉树的高度。
如果轴点恰好平分两个待排序部分，那么递归深度达到最优，即O(logN)，但如果轴点使两部分极不平衡，那么二叉树就会退化为单链表，其深度会达到O(N)。
9. 算法的5个基本特征：==确定性、有穷性、输入、输出、可行性==。